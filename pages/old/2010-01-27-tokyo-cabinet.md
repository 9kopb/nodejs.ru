# Хранилища данных в Node.js: Tokyo Cabinet/Tokyo Tyrant


Этим постом я начинаю серию о key-value stores, доступных из Node.js. Вообще то первым должен был быть пост о [Redis](http://code.google.com/p/redis/), но т.к. сам Redis недавно [обновился до 1.2](http://code.google.com/p/redis/downloads/detail?name=redis-1.2.0.tar.gz&can=2&q=) а [соответствующий модуль](http://github.com/fictorial/redis-node-client/tree/master) для node - ещё не успел, мы начнём с Tokyo Tyrant.


## Tokyo Cabinet, Tokyo Tyrant

Вкратце: Tokyo Cabinet - встраиваемое хранилище данных, очень продуманное и быстрое. В отличие от memcached или redis данные могут сбрасываться на диск. Таким образом, убирается ограничение "весь набор данных должен помещаться в RAM". Сам по себе Tokyo Cabinet существует в виде библиотеки и для непосредственного использования в Node малопригоден. Но существует ещё сервер Tokyo Tyrant, который превращает то же хранилище в удобный TCP-процесс со своим протоколом (и поддержкой протокола memcache). Коннектор для Tokyo Tyrant разрабатывается Github-пользователем [waveto](http://github.com/waveto).

## Установка и настройка

Устанавливается эта парочка достаточно просто. Качаем нужные архивы:

*   [Tokyo Cabinet](http://1978th.net/tokyocabinet/#packages)
*   [Tokyo Tyrant](http://1978th.net/tokyotyrant/#packages)

Есть ещё движок полнотекстового поиска [Tokyo Dystopia](http://1978th.net/tokyodystopia/#packages), но его мы разберём как нибудь в другой раз. Распаковываем полученное (я выделил для них отдельную папку):

Возможно, когда Вы будете ставить эту связку, версии уже изменятся (работа над ними идёт довольно активно). Для сборки tokyo Cabinet потребуется пакет **libbz2-dev**. Если его не установить, на стадии конфигурации Вы получите сообщение `configure: error: bzlib.h is required`. Поэтому поставим его сразу, чтобы потом к этому не возвращаться:

Вот теперь мы готовы. Сначала нам надо собрать Tokyo Cabinet, потом Tokyo Tyrant:

`Make clean` убирает ненужный мусор, остающийся после компиляции. Работать конечно будет и без этой команды, но в соответствующих каталогах останется много файлов неясного назначения. Чтобы потом не путаться, лучше сразу за собой прибрать.

Итак, если всё прошло правильно, сервер Tokyo Tyrant должен быть готов к работе. В той же директории, где мы его собирали, выполняем:

Сервер запустится на всех интерфейсах и на порту по умолчанию 1978\. Его можно будет увидеть в списке процессов: `ps ax`.

## Подключение и использование коннектора

Скачиваем сам коннектор со [страницы загрузок](http://github.com/waveto/node-tyrant/downloads). Если Вы используете последние версии Tokyo Cabinet/Tokyo Tyrant, коннектор тоже должен быть последней стабильной версии. На момент написания статьи я использую [v0.1.3](http://github.com/waveto/node-tyrant/zipball/v0.1.3). Можно скачать на хост-машину и передать в виртуальную, можно скачать сразу из виртуальной wgetом. Распаковываем, пробуем запустить:

Если сервер запущен, и для него указан порт по умолчанию, `demo.js` должен вывести статус сервера. Если подключиться не удастся, скрипт просто молча завершится. Если это произошло, найдите процесс `ttserver` в выводе `ps ax` и проверьте параметр `-port`. Если процесса нет, запустите сервер.

В коде использовать коннектор очень просто:


Функция `connect()` может принимать порт и имя сервера (именно в таком порядке). К сожалению, похоже сейчас не поддерживается расширенный тип записей Tokyo Tyrant - таблицы. Завтра постараюсь прояснить этот вопрос.

## Ссылки по теме

[Руководство по установке от ruoto, которое я использовал в качестве основы](http://openwferu.rubyforge.org/tokyo.html)  

[Свежая версия Tokyo Cabinet](http://1978th.net/tokyocabinet/#packages)  

[Свежая версия Tokyo Tyrant](http://1978th.net/tokyotyrant/#packages)  

[Коннектор node-tyrant от waveto](http://github.com/waveto/node-tyrant/tree/master)

Источник: [http://kuroikaze85.wordpress.com/2010/01/26/node-js-storage-tokyo-cabinettokyo-tyrant](http://kuroikaze85.wordpress.com/2010/01/26/node-js-storage-tokyo-cabinettokyo-tyrant)
